Примитивные и ссылочные типы в Java
В Java все данные делятся на два основных типа: примитивные типы и ссылочные типы. Понимание различий между ними и их хранение в оперативной памяти важно для написания эффективного кода.

Примитивные типы
Примитивные типы — это базовые типы данных, которые непосредственно хранят значения. В Java существует 8 примитивных типов:

byte (1 байт)
short (2 байта)
int (4 байта)
long (8 байт)
float (4 байта)
double (8 байт)
char (2 байта)
boolean (размер зависит от JVM, обычно 1 байт)
Примитивные типы хранятся непосредственно в памяти, выделенной для таких переменных - как в стеке, так и в куче, в зависимости от того, являются ли они локальными переменными или полями объекта.

Объекты и их поля хранятся в куче.
Локальные переменные и ссылки на объекты хранятся в стеке.
Если примитивный тип объявлен как локальная переменная в методе, он будет храниться в стеке. Это происходит потому, что локальные переменные имеют короткое время жизни и существуют только в пределах выполнения метода.
Если примитивный тип является полем класса, то есть полем объекта, то он будет храниться в куче. Это связано с тем, что объект, которому принадлежат эти поля, создается в куче.
Ссылочные типы
Ссылочные типы представляют собой объекты и массивы. Примеры ссылочных типов:

строки (String)
массивы
пользовательские классы
Ссылочные типы хранятся иначе, чем примитивы. Когда создается объект:

переменная, которая ссылается на этот объект, хранит только адрес (или ссылку) на эту область памяти и она хранится в стеке.
сам объект хранится в куче, где под него выделяется память.
Upper, down casting для переменных ссылочного типа. Оператор instanceof.
Ссылка родительского типа (Computer) может ссылаться на объект дочернего типа (Laptop, SmartPhone).
При создании массива Computers[] computers = new Compuner[7] мы создаем объекты типа Computer и все computers[i] - это объекты типа Computer.

В этом случае Java сама проводит upper casting (восходящее преобразование). Пример: computers[3] = new Laptop("M2", 16, 1024, "Apple", 3000, 14.1, 2.6, 10);

Восходящее преобразование происходит автоматически и не требует явного указания. Это безопасная операция, поскольку любой объект дочернего типа также является объектом родительского типа. Именно поэтому мы легко создаем массив объектов типа Computer и создаем в нем объекты дочерних классов Laptop и SmartPhone. Однако поля и методы дочерних классов остаются недоступными до тех пор, пока мы не сделаем down casting. computers[3] надо явно сделать объектом дочернего класса Laptop. Это можно сделать лишь тогда, когда

(computers[3] instanceof Laptop) - в скобках логическое выражение.

Проверить соответствие типов, можно при помощи оператора instanceof.

Если попытаться ссылке дочернего типа присвоить значение ссылки родительского типа, то компилятор потребует явно провести кастинг (down casting). При этом, если ссылка родительского типа указывает на другой дочерний объект, то в процессе выполнения кода, произойдет ошибка.

Сравнивать объекты через "==" некорректно, т. к. "==" сравнивает формально равенство ссылок, т. е. адреса объектов. А нужно сравнивать "по полям". Все объекты в Java являются наследниками класса Object. Для сравнения объектов в классе Object определен метод equals. Если хотим, чтобы объекты нашего класса сравнивались между собой по нужным нам полям, то надо переопределить метод equals в нашем классе, указав в нем логику сравнения заданного объекта с другим.
Объекты класса String создаваемые при помощи двойных кавычек, являются стринговыми константами. Это означает, что когда мы каждый раз указываем стринг с одинаковым содержимым в двойных кавычках, то новый объект не создается. Мы получаем ссылку на один и тот же объект.
Наследование - важные дополнения
Если необходимо запретить наследование от класса, то используется модификатор final.
final class SuperMan { ... }

Все классы у которых явно не указан супер-класс, наследуются от класса Object. То есть класс Object является родителем всех классов в Java по умолчанию. В том числе, все классы наследуют от класса Object метод toString, возвращающий строковое представление объекта (поля и их значения в одной строчке). Именно поэтому над каждым методом toString() стоит аннотация @Override
Проверить соответствие типов (родство объектов разных классов), можно при помощи оператора instanceof.