Stream
Stream можно создать для любого итерируемого объекта (JCF). Стрим это последовательность операций над элементами итерируемого объекта. объекты Car -> GarageImpl - garage фрукты Абрикос (кость + мякоть) -> ящик -> контейнер (ящики с абрикосами) посылки (адрес, вес, стоимость, страховка) -> перевозка в контейнере -> на корабль/в грузовик -> разобрать и оприходовать на склад -> отправить по адресатам

С появлением Java 8 Stream API позволило программистам писать существенно короче то, что раньше занимало много строк кода, а именно — упростить работу с наборами данных, в частности, упростить операции:

фильтрации (отбор данных по критерию),
сортировки,
преобразование,
и другие манипуляции с данными (см. ниже).
Стримы состоят из промежуточных и терминальных операций. Промежуточных операций может быть несколько и они всегда возвращают стрим. Терминальная операция может быть только одна, и она помещается в конец стрима. Терминальная операция возвращает результат работы всего стрима.

Стрим "ленивый". Т. е. стрим начнет работать, только когда к нему будет добавлена терминальная операция. Стрим не "трогает" (не изменяет) объект - источник.

Если в стриме, "на конвеере", оказываются объекты, которые в свою очередь являются итерируемыми, то при помощи промежуточного метода flatMap можно "вытрусить" содержимое этих объектов. В таком случае далее "по конвееру" будет двигаться уже содержимое объектов.

Терминальный метод collect может собрать содержимое стрима в нужную нам структуру. Для этого ему надо передать объект имплементирующий интерфейс Collector. На практике имплементировать самим интерфейс Collector приходится редко, т. к. в классе Collectors есть много методов возвращающих разнообразные коллекторы. Например, при помощи Collectors.toList(), можно получить коллектор собирающий элементы стрима в лист, а при помощи Collectors.toSet() - в сет.

Collectors.groupingBy позволяет сгруппировать элементы стрима в мапу, по ключу, который определяется соответствующей функцией. При этом элементы соответствующие одному ключу собираются по умолчанию в лист.

У Collectors.groupingBy есть перегруженные варианты. Например, вместо дефолтного листа, в качестве values можно использовать результат работы какого-нибудь коллектора.

Подробно о схеме работы стрима и основных операциях, смотрите в презентации.

Полезные статьи: https://javarush.com/groups/posts/2203-stream-api https://metanit.com/java/tutorial/10.1.php

Операции с данными с помощью Stream API
Stream API Java поддерживает целый ряд операций, которые позволяют гибко манипулировать данными. Помимо главных - фильтрации, сортировки и преобразования, к другим важным манипуляциям с данными относятся:

1. СведЕние (Reduction)
   Сведение позволяет агрегировать элементы потока, например, путем вычисления суммы, нахождения максимального или минимального значения, объединения всех элементов в строку и т.д.
   Методы: reduce(), collect().
2. Группировка и разделение (Grouping and Partitioning)
   Эти операции полезны для организации элементов потока по группам или разделения их на категории по определенному критерию.
   Используется чаще всего в сочетании с Collectors, например, Collectors.groupingBy() и Collectors.partitioningBy().
3. Преобразование в коллекции или массивы (Collecting to Collections or Arrays)
   Позволяет преобразовать поток обратно в коллекцию или массив.
   Метод: collect() с Collectors.toList(), Collectors.toSet(), или преобразование в массив через toArray().
4. Поиск и соответствие (Searching and Matching)
   Определяет, удовлетворяют ли элементы потока определенным условиям (например, поиск первого элемента, поиск любого элемента, проверка на наличие соответствий).
   Методы: anyMatch(), allMatch(), noneMatch(), findFirst(), findAny().
5. Объединение (Concatenation)
   Объединяет два потока в один.
   Метод: Stream.concat().
6. Лимитирование и пропуск элементов (Limiting and Skipping Elements)
   Эти операции позволяют обрезать поток, оставляя только определенное количество элементов, или пропустить первые элементы.
   Методы: limit(), skip().
7. Параллельная обработка (Parallel Processing)
   Позволяет обрабатывать поток данных параллельно, что может повысить производительность при работе с большими объемами данных.
   Метод: parallelStream() или stream().parallel().
8. Удаление дубликатов (Removing Duplicates)
   С помощью distinct() можно убрать повторяющиеся элементы в потоке.
9. Проверка данных (Peeking)
   Метод peek() позволяет выполнить действие для каждого элемента, не изменяя его, что удобно для отладки или временной записи значений на промежуточных этапах.
   Каждая из этих операций помогает более гибко и мощно работать с данными, предоставляя возможности, необходимые для различных сценариев их обработки.