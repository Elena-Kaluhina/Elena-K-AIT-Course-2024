Коллекции и итератор
Коллекции в Java — это набор классов и интерфейсов, которые представляют различные структуры данных и позволяют работать с группами объектов. Коллекции упрощают управление, хранение и обработку данных, предоставляя удобные и эффективные инструменты (методы) для работы с данными разного типа.

Зачем нужны коллекции? Коллекции делают работу с данными проще и эффективнее за счёт стандартных методов для добавления, удаления, поиска и сортировки элементов, не требуя от разработчика реализации этих алгоритмов вручную.

Зачем нужен итератор кратко, не вдаваясь в подробности:
В Java интерфейс Iterator служит для последовательного перебора элементов коллекций (например, списков, множества и других структур данных. Основная цель интерфейса Iterable — предоставить стандартизированный способ прохода по элементам коллекции, не раскрывая её внутреннюю структуру.

Зачем нужен итератор развернуто:
Когда объект (список, множество и пр.) инкапсулирует внутри себя множество элементов, то, как правило, имеется необходимость перебрать все элементы этого множества.

Вариант решения 1: Если для перебора создать геттер такого объекта, то возвращая на него ссылку, мы по сути даем небезопасный доступ ко всему множеству за пределами объекта. Получивший эту ссылку по геттеру затем может безконтрольно менять содержимое множества внутри объекта. Вариант решения 2: Если возвращать копию множества, то это негативно влияет на производительность, так как множество может быть весьма и весьма большим.

Паттерн Итератор
Для решения этой проблемы существует паттерн "Итератор". Суть паттерна – это создать сторонний объект, который "знает" как "перебирать" (итерировать) множество элементов, инкапсулированных в исходном объекте.

Объект итератор должен иметь две функциональности (два метода):

знать как определить есть ли следующий элемент - boolean hasNext();
вернуть текущий элемент и перейти к следующему - T next().
В Java существует интерфейс Iterator с двумя абстрактными методами: boolean hasNext(), возвращающий true если еще есть элементы, и false если дошли до конца множества, и T next() возвращающий текущий элемент, и переводящий "указатель" к следующему элементу. В интерфейсе Iterator существует еще дополнительный дефолтный метод void remove(), который имеет пустое тело. Если нам необходимо реализовать функциональность корректного удаления текущего элемента в процессе итерирования, то метод remove надо переопределить.

Класс инкапсулирущий множество, которое надо итерировать, может имплементировать интерфейс Iterable у которого только один абстрактный метод Iterator iterator(), возвращающий итератор для объектов данного класса.

Для Iterable объектов можно использовать цикл for-each. Его сигнатура вот такая: for (T e: "set of T"){ do_something; }; В теле этого цикла переменная "e" принимает поочередно значение каждого элемента из итерируемого множества.

ВНИМАНИЕ! В цикле for-each нельзя модифицировать итерируемое множество.

Complexity (вычислительная сложность)
Понятие Complexity (вычислительная сложность), позволяет оценить эффективность применяемых алгоритмических решений. Простым языком можно сказать, что вычислительная сложность говорит, пропорционально какой математической функции растет количество действий при обработке множества элементов, если увеличивать количество элементов этого множества.

Для описания вычислительной сложности используется т. н. "Big O notation".

Например, запись: O(1) говорит о константной сложности алгоритма - количество операций с элементами остается постоянным конечным числом и не растет при увеличении количества элементов. Пример: Количество элементов выросло в 100 раз, но при этом количество выполняемых в алгоритме операций не изменяется.

O(n) говорит о линейной сложности алгоритма - количество операций с элементами растет пропорционально количеству самих элементов. Пример: кол-во элементов выросло в 100 раза -> количество операций выросло также в 100 раз

O(log(n)) характеризует логарифмическую сложность - количество операций с элементами растет на порядок меньше, чем количество самих элементов. Пример: кол-во элементов выросло в 100 раз -> количество операций выросло всего в 10 раз

ВНИМАНИЕ! На выбор используемой из Collections структуры влияют два основных фактора:

Наличие или отсутствие в коллекции дубликатов
Вычислительная сложность алгоритмов во внутренних методах коллекции
1. Наличие или отсутствие дубликатов
   Если нужны дубликаты, то подойдут такие структуры, как List (например, ArrayList, LinkedList), где можно хранить несколько одинаковых значений.
   Если дубликаты не допускаются, выбирают Set (например, HashSet, TreeSet, LinkedHashSet). Эти структуры автоматически гарантируют уникальность элементов.
2. Вычислительная сложность операций
   Вычислительная сложность влияет на производительность программы и зависит от того, какие операции будут чаще всего выполняться:

Добавление и удаление элементов:

В ArrayList добавление в конец выполняется за (O(1)), но удаление или вставка в середине — за (O(n)).
В LinkedList операции добавления и удаления в начале и в конце эффективны ((O(1))), но вставка и удаление в середине могут быть медленными ((O(n))), так как требуют перемещения указателей.
Поиск элементов по значению или ключу:

В HashSet и HashMap доступ к элементам занимает (O(1)) в среднем, так как они используют хеширование.
В TreeSet и TreeMap поиск, добавление и удаление имеют сложность (O(log n)), поскольку они реализованы как сбалансированные деревья и поддерживают порядок.
Примеры выбора коллекции по этим критериям:
Если нужны уникальные элементы и быстрый поиск: HashSet.
Если нужны уникальные элементы в отсортированном порядке: TreeSet.
Если нужна структура с дубликатами и доступ по индексу: ArrayList.
Если нужна очередь с элементами, которые будут извлекаться в определённом приоритете: PriorityQueue.
Таким образом, исходя из наличия/отсутствия дубликатов и требуемой производительности основных операций, можно выбрать коллекцию, которая обеспечит наиболее эффективное выполнение задачи.