Wrapper classes - кратко
Классы-обёртки в Java (wrapper classes) нужны для того, чтобы работать с примитивными типами данных как с объектами. Каждый примитивный тип данных в Java имеет соответствующий класс-обёртку: int → Integer char → Character boolean → Boolean byte → Byte short → Short long → Long float → Float double → Double
Классы-обёртки содержат полезные методы, которые нельзя применить к примитивам. Например: Преобразование строк в числа: Integer.parseInt("123") Преобразование числа в строку: Integer.toString(123) Методы для перевода чисел из одной системы счисления в другую. И еще много полезных методов.
Для удобства работы с wrapper classes в Java реализован механизм автоупаковки (autoboxing) и автораспаковки (autounboxing). Это означает, что мы можем использовать в математических действиях объекты "классов оберток" наравне с примитивными типами. Java, при необходимости, автоматически преобразует объект "класса обертки" в соответствующий ему примитивный тип (autounboxing), или наоборот - примитивный тип упакует в объект wrapper класса (autoboxing).
Wrapper classes имеют полезные константы и методы. Например Integer.MAX_VALUE хранит максимально возможное число целого типа, а статические методы Double.isNaN(double a) и Double.isInfinite(double a), могут проверить хранит ли передаваемый аргумент специальные значения NaN и Infinite соответственно.
Wrapper classes при помощи методов парсинга (начинаются со слова parse...), могут преобразовать строки (данные типа String) в соответсвующий данному wrapper классу примитивный тип. Если строка содержит набор символов, который можно интерпретировать как число, то парсинг пройдет успешно. Если нет, то будет ошибка.
Аргументы командной строки
Аргументы командной строки в Java позволяют передавать данные программе при её запуске через командную строку. Это полезно, когда вы хотите, чтобы программа получала ввод или настройки без необходимости взаимодействия с пользователем во время работы программы.

Вы можете передать аргументы через аргументы метода main. Эти аргументы передаются программе в виде массива строк String[] args, который является параметром метода main.

Wrapper-классы более подробно
У примитивных типов есть объекты-аналоги - так называемые "классы оболочки", или "wrapper" (с англ. "обертка, упаковка"):

Primitive Data Types	Wrapper Classes
int	Integer
short	Short
long	Long
byte	Byte
float	Float
double	Double
char	Character
boolean	Boolean
Класс называется "оболочкой" потому, что он, по сути, копирует то, что уже существует, но добавляет новые возможности для работы с привычными типами.

Объекты классов оболочкой создаются так же, как и любые другие:

public static void main(String[] args) {

Integer i = new Integer(682);

Double d = new Double(2.33);

Boolean b = new Boolean(false);
}
Copy
Зачем они нужны?
Примитивы и их аналоги, классы оболочки, существуют параллельно, потому что у каждого есть свои преимущества.

Например, обычный int занимает меньше места, и годится, если нет необходимости проводить над ним особые операции.
с помощью класса-оболочки Integer можно выполнять специальные операции - например, перевести текст в число (с помощью метода .parseInt() для Integer-а ). Если попробовать сделать это с помощью кода самому придется писать метод, который должен взять каждый символ, проверить, является ли он цифрой, перевести символ в цифру, добавить цифру в число и в итоге вернуть сформированное число.
Примитивные типы потому и называют примитивными, потому что они лишены многих “тяжеловесных” особенностей объектов. Да, у объекта есть много удобных методов, но ведь они не всегда нужны.

Autoboxing/Autounboxing
Одной из особенностей примитивов и их классов-оберток в Java является автоупаковка/автораспаковка ( Autoboxing/Autounboxing)

Переменной класса-обертки можно присваивать значение примитивного типа. Этот процесс называется автоупаковкой (autoboxing).

Точно так же переменной примитивного типа можно присваивать объект класса-обертки. Этот процесс называется автораспаковкой (autounboxing).

public class Main {
public static void main(String[] args) {
int x = 7;
Integer y = 111;
x = y; // автораспаковка
y = x * 123; // автоупаковка
}
}
Copy
Методы классов оболочек
Методы valueOf()
Иногда в объекте типа String содержится число, и Вам нужно с ним работать дальше Метод valueOf() предоставляет второй способ создания объектов оболочек. Метод перегруженный, для каждого класса существует два варианта - один принимает на вход значение соответствующего типа, а второй - значение типа String. Так же как и с конструкторами, передаваемая строка должна содержать числовое значение. Исключение составляет опять же класс Character - в нем объявлен только один метод, принимающий на вход значение char.

И в целочисленные классы Byte, Short, Integer, Long добавлен еще один метод, в который можно передать строку, содержащую число в любой системе исчисления. Вторым параметром вы указываете саму систему исчисления.

public class WrapperValueOf {
public static void main(String[] args) {
Integer integer1 = Integer.valueOf("6");
Integer integer2 = Integer.valueOf(6);


        System.out.println(integer1);
        System.out.println(integer2);
    }
}
Copy
Методы parseXxx()
В каждом классе оболочке содержатся методы, позволяющие преобразовывать строку в соответствующее примитивное значение. В классе Double - это метод parseDouble(), в классе Long - parseLong() и так далее. Разница с методом valueOf() состоит в том, что метод valueOf() возвращает объект, а parseXxx() - примитивное значение.

Также в целочисленные классы Byte, Short, Integer, Long добавлен метод, в который можно передать строку, содержащую число в любой системе исчисления. Вторым параметром вы указываете саму систему исчисления. Следующий пример показывает использование метода parseLong():


public class WrapperDemo3 {
public static void main(String[] args) {
Long long1 = Long.valueOf("45");
long long2 = Long.parseLong("67");

        System.out.println("long1 = " + long1);
        System.out.println("long2 = " + long2);
    }
}
Copy
Методы toString()
Все типы оболочки переопределяют toString(). Этот метод возвращает читабельную для человека форму значения, содержащегося в оболочке. Это позволяет выводить значение, передавая объект оболочки типа методу println():

Double double1 = Double.valueOf("4.6");
System.out.println(double1);
Copy
Также все числовые оболочки типов предоставляют статический метод toString(), на вход которого передается примитивное значение. Метод возвращает значение String:

String string1 = Double.toString(3.14);
Copy
Integer и Long предоставляют третий вариант toString() метода, позволяющий представить число в любой системе исчисления. Он статический, первый аргумент – примитивный тип, второй - основание системы счисления:

String string2 = Long.toString(254, 16); // string2 = "fe"
Copy
Методы toHexString(), toOctalString(), toBinaryString()
Integer и Long позволяют преобразовывать числа из десятичной системы исчисления к шестнадцатеричной, восьмеричной и двоичной системе. Например:


public class WrapperToXString {
public static void main(String[] args) {
String string1 = Integer.toHexString(254); // целое число 254 переводится в 16-ричное
System.out.println("254 в 16-ой системе = " + string1);

        String string2 = Long.toOctalString(254);
        System.out.println("254 в  8-ой системе = " + string2);

        String string3 = Long.toBinaryString(254);
        System.out.println("254 в  2-ой системе = " + string3);
    }
}
Copy
В классы Double и Float добавлен только метод toHexString().

Пример приведения типов
Integer iOb = new Integer(1000); // создаем объект

        System.out.println(iOb.byteValue());    // byte
        System.out.println(iOb.shortValue());   // short
        System.out.println(iOb.intValue());     // int
        System.out.println(iOb.longValue());    // long
        System.out.println(iOb.floatValue());   // float
        System.out.println(iOb.doubleValue());  //double
Copy
Статические константы классов оболочек
Каждый класс оболочка содержит статические константы, содержащие максимальное и минимальное значения для данного типа.

Например, в классе Integer есть константы Integer.MIN_VALUE – минимальное int значение и Integer.MAX_VALUE – максимальное int значение.

Аналогичные константы есть в классе BigInteger.